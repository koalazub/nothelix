# Notebook Structure Verification

## Converted Notebook Format

### File Header
```julia
# Nothelix Notebook - Runnable Julia Script
# Source: /path/to/notebook.ipynb
#
# This file can be:
# - Run directly: julia this_file.jl
# - Edited and executed cell-by-cell in Helix with Nothelix
# - Synced back to .ipynb with :sync-to-ipynb

# No-op macro for cell markers (allows standalone execution)
macro cell(idx, exec_count) end
macro markdown(idx) end
```

**Generated by:** `convert_notebook_impl()` (lib.rs:1687-1702)

### Code Cell Structure
```julia
# ═══════════════════════════════════════════════════════════════════
@cell 0 nothing
using Plots, LinearAlgebra
x = 1:10
```

**Format:**
- Line 0: Cell separator (visual only)
- Line 1: `@cell <index> <exec_count>` where exec_count is number or "nothing"
- Line 2+: Raw Julia code

**Generated by:** `convert_notebook_impl()` (lib.rs:1714-1725)

**Parsed by:**
- `find_next_cell_ffi()` (lib.rs:1982-1993) - looks for `@cell ` prefix
- `get_cell_bounds_ffi()` (lib.rs:2027-2035) - extracts index and exec_count
- Code extraction: `lines[code_start..code_end]` (lib.rs:2121-2125)

### Markdown Cell Structure
```julia
# ═══════════════════════════════════════════════════════════════════
@markdown 0
#=
# Wavelet Analysis

$$
\newcommand{\ip}[2]{\langle#1,#2\rangle}
$$
=#
```

**Format:**
- Line 0: Cell separator (visual only)
- Line 1: `@markdown <index>`
- Line 2: `#=` (Julia multiline comment start)
- Line 3+: Markdown content
- Last line: `=#` (Julia multiline comment end)

**Generated by:** `convert_notebook_impl()` (lib.rs:1727-1751)

**Parsed by:**
- `find_next_cell_ffi()` (lib.rs:1982-1993) - looks for `@markdown ` prefix
- `get_cell_bounds_ffi()` (lib.rs:2036-2044) - extracts index
- Markdown-specific extraction (lib.rs:2089-2117):
  - Detects `#=` wrapper at code_start
  - Skips `#=` line: `md_start = code_start + 1`
  - Finds `=#` terminator: `md_end`
  - Extracts only content: `lines[md_start..md_end]`
  - **Bug fixed:** Previously extracted `lines[code_start..code_end]` (included #=)

### Cell with Output
```julia
# ═══════════════════════════════════════════════════════════════════
@cell 1 42
result = sqrt(2)

# ─── Output ───
1.4142135623730951
# ─────────────
```

**Format:**
- Code cell as above
- Blank line
- `# ─── Output ───` marker
- Output text (plain text or with image markers)
- `# ─────────────` terminator

**Generated by:** `execute-cell` Steel command (nothelix.scm:220-282)

**Parsed by:**
- `get_cell_bounds_ffi()` (lib.rs:2068-2082) - stops at output marker
- Sets `code_end` at output marker line
- Sets `cell_end` at next cell or EOF

## Parsing Correctness

### Code Cell Parsing
✅ **CORRECT**
- Searches backwards for `@cell ` (lib.rs:2027)
- Extracts index from `@cell <idx> <exec_count>` (lib.rs:2031-2034)
- Code starts at line after marker (lib.rs:2053)
- Code ends at next marker or output section (lib.rs:2059-2083)

### Markdown Cell Parsing
✅ **FIXED** (lib.rs:2089-2117)
- Searches backwards for `@markdown ` (lib.rs:2036)
- Correctly skips `#=` wrapper (lib.rs:2093-2095)
- Correctly finds `=#` terminator (lib.rs:2096-2101)
- **Fixed:** Now extracts `lines[md_start..md_end]` excluding markers
- Returns clean markdown content without Julia comment syntax

### Navigation
✅ **CORRECT**
- `find-next-cell`: Searches forward for lines starting with `@cell ` or `@markdown ` (lib.rs:1986-1989)
- `find-prev-cell`: Searches backward for same markers (lib.rs:2002-2005)
- Both trim whitespace before checking (lib.rs:1987, 2002)

### Execution
✅ **CORRECT**
- `get-cell-bounds` extracts code between markers (lib.rs:2103-2125)
- `kernel-execute-sync` runs code synchronously (lib.rs:2331-2401)
- Parses output for text and image data (lib.rs:2378-2390)
- Detects `__IMAGE_DATA__` / `__END_IMAGE__` markers for plots

## Structure Alignment

| Component | Conversion | Parsing | Status |
|-----------|-----------|---------|--------|
| File header | ✅ Lines 1687-1702 | N/A (skipped) | ✅ |
| Macro defs | ✅ Lines 1698-1700 | N/A (no-op) | ✅ |
| Code cells | ✅ Lines 1714-1725 | ✅ Lines 2027-2035 | ✅ |
| Markdown cells | ✅ Lines 1727-1751 | ✅ Lines 2089-2117 | ✅ FIXED |
| Cell separator | ✅ Visual only | ❌ Ignored | ✅ |
| Output sections | ✅ Steel command | ✅ Lines 2068-2082 | ✅ |

## Verification Test

### Input: notebook.ipynb
```json
{
  "cells": [
    {
      "cell_type": "markdown",
      "source": ["# Title\n", "Content"]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "source": ["x = 1\n", "y = 2"]
    }
  ]
}
```

### Output: notebook.jl
```julia
# [header omitted]

# ═══════════════════════════════════════════════════════════════════
@markdown 0
#=
# Title
Content
=#

# ═══════════════════════════════════════════════════════════════════
@cell 1 1
x = 1
y = 2
```

### Parsing Results

**find-next-cell(content, 0):**
- Returns: `7` (line with `@cell 1 1`)

**get-cell-bounds(content, 8):**
- cell_start: 7
- code_start: 8
- code_end: 10
- code: `"x = 1\ny = 2"`
- cell_type: "code"
- cell_index: 1

**get-cell-bounds(content, 2):**
- cell_start: 1
- code_start: 3 (after skipping `#=`)
- code_end: 5 (before `=#`)
- code: `"# Title\nContent"`
- cell_type: "markdown"
- cell_index: 0

✅ **All parsing matches generated structure**
